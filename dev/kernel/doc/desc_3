			   ==========================
			   Pinball System for TS-7200
			           Release K3
				   What's New
			   ==========================
				    cs452_08

1. Overview
===========

* Kernel
--------

- Added IRQ handling and Interrupt Manager
- Modified trap/context switch code to include IRQ states
- Implemented AwaitEvent syscall


* Userland
----------

- Added clock support
- Added time server and associated APIs, i.e. Time, Delay, DelayUntil


2. Kernel Component Changes Details
===================================

* AwaitEvent
------------

The prototype of AwaitEvent is:

int AwaitEvent( int eventid );

In Pinball kernel an event is defined as an interrupt.  An event id is simply
the interrupt id.  Therefore by definition only device drivers can call
AwaitEvent.  The intention is that all more complex events should be handled by
servers rather than the kernel.

The AwaitEvent call will call into the interrupt manager to enable the
interrupt, register the current task as the interrupt handler for the interrupt,
and then the task will be removed from the scheduler.  When the interrupt is
triggered another call into the interrupt handler will disable the interrupt,
and return the interrupt handler task to be added back to the scheduler.

The caller is expected to ensure that the specific device in concern is
setup/reset properly to generate the expected interrupt.


* Data Structures
-----------------

- New data structure: Interrupt Manager Descriptor

The Interrupt Manager Descriptor contains data needed by the interrupt manager
to handle interrupts.  It contains the array of interrupt handlers, mapped to
interrupt by array index.

- Kernel context

The kernel context now contains data needed by the Interrupt Manager.


* Functional Units
------------------

- New functional unit: Interrupt Manager

The interrupt manager manages the interrupt handlers and handles generic
interrupt controler operations.

The interrupt manager starts up with initializing all the interrupts that are
going to be used by the kernel.  Intialization take place by disabling all
interrupts and filling out the vectored interrupt registers
(vic_vect_addr[0-15]).  The vectored interrupt registers are filled with the
interrupt id rather than an ISR, because the kernel handles the interrupt by
pushing the interrupt back to the user space and the only information needed by
the kernel is the interrupt id.  Using the vectored interrupt registers we can
obtain the interrupt id with one ld operation.  Fast.

The interrupt manager supports 2 methods provided to the kernel: register and
handle.  Both are supposed to be called by the trap handler.

Register registers a task as the interrupt handler for the specified interrupt,
and then enables the interrupt in the VIC.  The task is supposed to be removed
from the scheduler then.  Register should be called when a device driver calls
AwaitEvent.

Handle will return the interrupt handler for the specified interrupt so that the
handler can be rescheduled, and disables the interrupt.  Handle should be called
when the trap handler receives an interrupt.

Handle identifies the interrupt by reading the vic_vect_addr register.


* Processes
-----------

- New process: interrupt trap, and change to trap process

Interrupt will cause the processor to enter IRO mode.  In Pinball we do not
initialize IRQ mode sp, so IRQ does not have the power to save any information.
Rather, we modified the swi trap code to not to clobber any register, saves both
user mode registers and IRO mode registers (which are just lr and spsr), and
pass the spsr into the trap handler for it to recognize the source of interrupt.
In the interrupt trap code we simply executes swi to trap into kernel, through
swi trap code.

This implies that when the task is rescheduled, it will be restored into IRQ
mode along with all the IRQ registers.  The instruction immediately following
swi in the interrupt trap code is:

subs pc, lr, #4

which moves the processor back into the user program the IRQ interrupted.


3. Userland Components Changes Details
======================================

* New service: time server a.k.a clock server
---------------------------------------------

The time server is an optimized clock server in the requirement of this
assignment. The timer server is designed to have much small number of sends
and/or replys. For this purpose, we removed the notifier, because the notifier
would send message to clock server every clock tick.

In our time server, we will create a clock driver to avoid the extra name server
query. When ever a request coming in, the time server will communicate with the
clock driver to resolve the request. When a Time() request comes in, the clock
driver will send a message to clock driver to ask for current time. When a
Delay() or DelayUntil(), the timer server will calculate the wake-up time of the
delaying task, and send this information to clock driver. The clock driver will
send a signal to time server when the earliest delay is done. Then time server
will reply to the delaying task to wake it up.

Notice with multiple tasks asking for delaying the clock driver only reply once
for the task that needs to be wake up earliest. Once the earliest task is waken
up, if there are multiple tasks delaying, the time server will calculate the new
delaying time for the next earliest task and send the request to the clock
driver. The tasks that needed to be waken up is kept in a min-heap to achieve
this in O(log n) time.

This is done as the given implementation of clock driver.


* New driver: clock driver
--------------------------

The clock driver is built based on requirements of the time server.  It consists
of 2 components: one is the driver which configures the clock hardware, and the
other which is a interrupt handler which awaits interrupt events from the clock.
The clock driver support 2 operations: obtaining current time and count down.

The clock driver starts with initializing clock 1 and 3, where clock 1 is used
to generate count down interrupts and clock 3 is used to keep track with the
current time.  Then the driver creates the clock interrupt handler task.

Whenever the clock driver receives a current time request it reads clock 3 to
find out how long clock 3 has been running, and calculate the current time from
this data.  Clock 3 is a 32 bit clock which runs 24 days with the 2000Hz clock
source.

We are not using constant clock interrupt to implement clock server as we think
it is too expensive to trigger a kernel access and context switches every 50 ms
than to simply read time from clk_3.  Interrupt is only used to implement count
down requests as requested by the time server.

When the clock driver receives a count down request, it checks if there is a
undergoing count down and how much time the current count down has left.  If
there is no count down going on or the current count down has more time left
than the requested count down, the driver will reset the clock to generate an
interrupt after the requested count down, and if no count down is going on, the
driver notifies the clock interrupt handler to wait for the interrupt.
Otherwise the clock interrupt handler must have been waiting on a shorter count
down, and the count down request is discarded.

The reason that the longer count down request can be discarded (either by
ignoring a longer request or replacing current count down with a shorter
request) is due to the way time server is implemented.  The time server will
always restore the task that has least amount of delay.  Therefore the clock
server will only keep track the shortest count down.

Each tick is defined to be 50 ms, which is equivalent to 100 ticks on the clock,
as required by the kernel specification.


* New user application: lazy dogs
---------------------------------

The lazy dog is a task that used to test the time server as required. All it
does is the test procedure as described in the assignment specification. It
creates 4 tasks, give different delay parameters, and wait until all 4 sub-tasks
to finish. The sub tasks will delay for the given duration, and print message as
they progress.


* Data Structures
-----------------

- Heap Structure

A new heap structure is added to user library. Each element in the heap is
consist of two fields: a key and a value. The heap is a minimun heap sorting on
the key of its elements. The heap has insert and remove methods of O(log n)
running time, and the it has a peak method to read the first element in the heap
for O(1) run time. The key value is an unsigned integer, and it will be sorted
unsignedly. The value field is an integer value, so it can be used directly, or
used as a pointer pointing to some data structure if needed. The maximum number
of elements in the heap is set to 256 elements.


3. Source Code
==============



4. Output
=========

As specified by the assignment no 2 timeouts should occur at the same time.
Therefore all output should get enough gap to print out its statues in sequence.

The output is augemented by the time caluculated from the out.

Time (ms) | Output
0         | task 7 starts
-         | task 8 starts
-         | task 9 starts
-         | task 10 starts
500       | task 7 has finished delay 1 of 500 ms
1000      | task 7 has finished delay 2 of 500 ms
1150      | task 8 has finished delay 1 of 1150 ms
1500      | task 7 has finished delay 3 of 500 ms
1650      | task 9 has finished delay 1 of 1650 ms
2000      | task 7 has finished delay 4 of 500 ms
2250      | task 8 has finished delay 2 of 1150 ms
2500      | task 7 has finished delay 5 of 500 ms
3000      | task 7 has finished delay 6 of 500 ms
3300      | task 9 has finished delay 2 of 1650 ms
3450      | task 8 has finished delay 3 of 1150 ms
3500      | task 7 has finished delay 7 of 500 ms
3550      | task 10 has finished delay 1 of 3550 ms
4000      | task 7 has finished delay 8 of 500 ms
4500      | task 7 has finished delay 9 of 500 ms
4600      | task 8 has finished delay 4 of 1150 ms
4950      | task 9 has finished delay 3 of 1650 ms
5000      | task 7 has finished delay 10 of 500 ms
5500      | task 7 has finished delay 11 of 500 ms
5750      | task 8 has finished delay 5 of 1150 ms
6000      | task 7 has finished delay 12 of 500 ms
6500      | task 7 has finished delay 13 of 500 ms
6600      | task 9 has finished delay 4 of 1650 ms
6900      | task 8 has finished delay 6 of 1150 ms
7000      | task 7 has finished delay 14 of 500 ms
7100      | task 10 has finished delay 2 of 3550 ms
7500      | task 7 has finished delay 15 of 500 ms
8000      | task 7 has finished delay 16 of 500 ms
8050      | task 8 has finished delay 7 of 1150 ms
8250      | task 9 has finished delay 5 of 1650 ms
8500      | task 7 has finished delay 17 of 500 ms
9000      | task 7 has finished delay 18 of 500 ms
9200      | task 8 has finished delay 8 of 1150 ms
9500      | task 7 has finished delay 19 of 500 ms
9900      | task 9 has finished delay 6 of 1650 ms
10000     | task 7 has finished delay 20 of 500 ms
10350     | task 8 has finished delay 9 of 1150 ms
10650     | task 10 has finished delay 3 of 3550 ms
 
Output explained:
It works.