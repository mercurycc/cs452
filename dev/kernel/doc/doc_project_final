                           ==========================
                           Pinball System for TS-7200
                                   Release P3
                                Train Controller
                           ==========================
                                    cs452_08

Overview
========

The train controller is a program that intends to provide a routining and
tracking mechanism.

At its present form it can only track the train, while although path finding is
working, it does not allow the train to stop at the intended location.

The application is formed with several functional units, such as train
communication module, automation module, sensor module, and control module.
Each train also owns a planner for path finding.

Algorithms used are intended to use only integer operations to keep result
as fast as possible while preserving sufficient accuracy.


Data Structure
==============

Train Data Structure
--------------------

Train Data is a large struct that stores many information needed by our
program. All our program's knowledge about the train is in the train data
structure, including constant information like id, and variable information
such as position, speed and route finding information.


Track Node Structure
--------------------

The track nodes are stored in the track structure offered on class webside. 
We did some modification to make it fit in our design, added a few data field using regular expressions, such as group, id, index, and fields for reservation systems.


Speed Table
-----------

The speed table records the speed of the train at each level. It has 30
different levels, since the train has different speed when accelerate into a
speed level than when decelerate into that speed level. However, actually only
28 levels will be used, since the train would not accelerate into speed 0, or
decelerate into speed 14( highest ). 

The speed table is supposed to record average speed a train has at certain speed level. Initially, it will automatically generate the speed for the new train according to a function. Different trains has different function models, and we will choose the correct one depending on which train we are initializing. When trains running on the track, everytime it hits a sensor, and if our program thinks it is running at a constant speed, it will update the speed table with an more accurate average speed.


Tracking Info
-------------

Tracking info of the train is stored as a structure called tracking. In this structure it stored all information the system needs in order to track the train. It contains last sensor hit, next sensor to hit, last and next check points, position (distance away from last checkpoint), and speed related variables.


Functional Units
================

Sensor Puller
-------------

The sensor puller pulls the sensor.

The puller stay at a rather low priority in order to not to stop other
components of the train application. It then sends the latest sensor report to
auto for data collection and sensor ui for presentation.

Pulling is done here in consideration of the case of multiple trains presenting
on the track.  Pulling is simpler and more robust.


Train Auto (Automation)
----------

Train auto is a server module of the train application intended to carry out
automated tasks, such as calibration, tracking, path finding and directing.

In practice it is more like a pulling loop.  This is because in order to
estimate and provide real time data to the train, auto has to run every several
ticks in order to update these data.  This is accomplished by making a task
sending wake up signals every several ticks.

Train control will send all the commands it received to auto.  


Train Module (Communication)
------------

The train_module is the task that communicates with the track. For any
instruction needs to send to the track, the train_module will communicate with
the UART server and send the corresponding bytes. 

Since the speed of sending instructions to the track cannot be too fast, so our module needs to insert delays between them. It achieves this by buffering all the commands it needs to send and has a delay notifier. Everytime an instruction is send to the track, the module replies the notifier about how long it should wait. After the notifier waited for enough time, it sends back to the module that telling module it is OK to send next instruction now. The module then send the next instruction. To get max efficiency, module may change the order of the instructions that it has buffered, or even discard some unnecessary ones, for instance, duplicate instruction of turning off the solenoid of the switch (So only the last one will be sent).


Reservation Server (Reservation)
------------------

The reservation server is in charge of all the track reservation requests. Whenever a train needs to reserve a piece of track, it sends request to the reservation server and wait for its response. The detailed algorithm for the server is in the later Algorithm section.



Train Control and Display Server (User Interface)
--------------------------------

The train_control task is the task that communicates with the user. It has 2
jobs: 1. read and parse user's input and send it to module (if necessary);
2. send feedback to the user. The control task is in charge
of the command line prompt. It reads input from the user, and buffer the input
until user pulls the trigger (e.g. hit enter key). Then the control task parse
the input, and do the corresponding work.

The Display server is in charge of all kind of displaying job. Whenever a task needs to display anything on screen, it sends to the display server with the information it wishes to show and the position it prefers. The display server will buffer these information and update the screen every 3 ticks of system time.


Train Planner ( Path Finding )
-------------

The train planner is a task binds to a train, planning the path for the train, and executing the plans.



Train Schedule Server ( Train Scheduling )
---------------------

The scheduler will schedule any free trains it has to complete the given routines. A routine has a source location and a destination location. A train is meant to go to a source location first, and then travel from the source location to the destination location. You can think it as a shipping request. A free train needs to go to the start location to pickup some cargo, and escort the cargo to the destination location.

The scheduler depends heavily on the planner, as it requires the planner to carry out the path finding and the actual execution.How these two cooperates will be discussed in Algorithm section.




Calibration and Algorithms
==========================

Initial Calibration
-------------------

The initial calibration is important to our system, since our system predict the speeds of different level of a train depending on this calibration.

The procedure works like this: The train will first hit 3 continuous sensors so that the system can determine its position. Then the train will run at speed 8 and speed 12 for 5 seconds each, not include the speed change time, to get accurate speed for speed 8 and speed 12. Then it will calculate all the speeds using these two readings. Different trains has rather different speed models. For the working trains now, train 21 has a nice curve, train 23 has a linear distribution, and train 24 has linear, step-like speed distribution.


Speed Calculation
-----------------

When hitting a sensor, the program would know 2 things about the train: the time
that the train to hit the last sensor, and the time this train hit the current
sensor. With the track information, the program can calculate the distance
between the sensors, and thus calculate the speed of the train.

Update Speed Table
------------------

We calculate average speed in such a way:

avg = (old * k + new) / (k + 1)

Beside the speed table, we have a variable called speed count. It is the k value
in the formula. The meaning of this k value is that how reliable our old data
is. Initially, k is small, as all data are predicted. New speed readings has huge
impact on the avg value. As we taking more and more samples form the track, we
will get higher k values, and thus saying the old value are pretty concrete at
this time. So new reading value is going to have less impact on the speed
record.


Sensor Attribution and Error Tolerance
--------------------------------------

Sensor arribution is done with combination of the both error tolerance and
reservation system. It is not too complicated, but effective enough to allow
program to track multiple trains.

The sensor attribution is accomplished by mainly recording two piece of
information. First we record in train's data structure that the sensors it is
expected to hit. Whenever a train is successfuly registered, it predicts 2 or 3
sensors that it would hit. At the same time, we will mark these sensor as being
expected by some train. When the train moves on and hit one of the sensor it is
expecting, it will clear the old predictions and predict next a couple sensors
based on this sensor report. With this, when different trains are expecting
different sensors, we can distinguish which train actually hit this sensor when
multiple trains are running on the field.

However, it may comes to a situation where 2 trains are one the track, two
trains may expecting same sensor at ones. In order to distinguish which train
hit the sensor, we combined the sensor checking with the reservation system. The
key idea is: a train will only hit a sensor when it reserves the block after
it. In situation like a sensor is the primary of the first train and secondary
of the second train, when this sensor is hit, the program will check which train
has reserved that block of the track, thus deside which train triggered the
sensor.

Sometimes, a sensor would fail. For example, train 23 cannot hit A04 on track
B. Because of such cases, our program will predict not just one, but next two
sensor that a train going to hit. If the train didn't hit the primary sensor (
which is the sensor that the train is expected to hit next ), when the train hit
the secondary sensor ( the further one ), the program will catch this and update
train's location. Therefore, the train would not lostm, for single sensor error.

Whenever a sensor makes a mistake, either not triggered when it is supposed to (
eg. disconnected ), or triggered when it is not supposed to ( eg. stucked, as
always being triggered ), the program will mark that sensor less
trustable. Whenever a sensor worked normally, the program will mark that sensor
more trustable. If a sensor gives error often, it will be mark less and less
trustable until it gets to a stage where the program will mark this sensor
invalid. In this situation, the sensor will be ignored.

It is similar for switch error. We made the train expecting the sensor that it
would hit if the switch is in a different setup. This is named as tertiary
sensor. When a train hit its tertiary sensor, the program will update its
location. However, currently, the path finder task is not connected in this
part. So when a switch error happens, the train would not lost, but we have to
manually stop the train and manually ask path finder to give a new path. We are
about to change this in next a few days, since our final project need this.



Distance and Landmark Prediction
--------------------------------

The distance of the train means how long is it away from the last landmark it
massed. Since we don't get readings from the track other than sensors, we has to
predict where train is when train is not on a sensor. In our program, we use the
speed information we had and the time information to predict if our train has
passed a landmark or not, and how far has it gone since the last land mark.


Positioning when Speed is Changing
----------------------------------

In order to find the train's speed when speed is changing, we emulated the speed
change procedure. Our emulation uses a linear function for simplicity. It
records the time when the speed change is issued, and using init speed value and
end speed value for the speed table to calculate the distance the train has
traveled at a certain point of time.

This model's correctness depends on the correctness of train's speed change time. Since each trains are different, we need manually input the speed change time parameter for each train. For this and some other situations, we added a few commands to modify arguments directly from the prompt. The commands will be talked later.


Reservation System
------------------

The reservation system is a task that manipulates the track and train data to
implement track reservations.

The reservation algorithm is implemented based on modifications to the
track/train data structure.  Now each edge of the track contains an array of
reservation structurs mapping to all the trains, each contain a pair of integers
indicating which portion of the edge the train is reserving, a pointer to a
train structure indicating which train might be reserving the track, and an
integer passcode for verifying the reservation.  In the train structure there is
a field of matching integer passcode.

To reserve, the train asks the reservation system for a range to reserve ahead
of the train.  The reservation system follows the path from the train's last
landmark, reserving each edge possible, until the whole range is convered.
While reserving each edge, the train and its passcode is written to the
reservation structure in the edge to indicate a successful reservation. If the
range requested on the edge or its reverse edge is reserved, a reservation
failure is returned.

The system does not support release of only one edge but to release all the
edges reserved all at once.  The train always simply give up all its
reservations and re-reserve the path ahead of the train to simplify the
algorithm.  This also makes the algorithm more robust.

The criteria for an edge being reserved allowed releasing all reservations of a
train to be cheap.  An edge is reserved if the edge or its reversed edge fulfill
both the conditions that the pointer to a train is non-null, and the passcode
recorded matches the passcode in the train structure of the train recorded.

Thus to release all the reservations of a train, the reservation system simply
increment the passcode in the train structure.

The reason releasing one edge at a time isn't robust enough is because in the
case of the train running at high speed and the software missing the update on
an edge, it requires much more effort to release the missed edge.  Also to make
the train reserve an edge at a time also requires a lot of careful design to
ensure missed updates does not affect the reservation.

Given enough processing power and under the assumption that the train will not
reserve a huge number of nodes, the implemented algorithm is expected to perform
well enough not to interfere other tasks running on the system.

The train should restart its trip via an alternative route if a collision is
found, or simply stop to wait for further instructions if it is on free run
mode.

To break a live lock caused by re-routing we used existing properties in the
system to break the live lock by making the earlier registered train to replan
its trip first, so ideally the live lock will not persist forever.  A random
backup is also implemented to ensure the behavior.

The reservation system also protects train from running out of an exit. When a
train tries to reserve the track in front of it and find it is an exit, the
reservation will fail, and the train will be forced to stop.

In particular locations such as branch and merges, the train will reserve the
sections of both direction of the track, so if would not hit any trains on the
track of the other direction of a switch.



Path Finding Algorithm and Path Execution
-----------------------------------------

The goal was to find the shortest path in term of distance.

The algorithm at its present form runs the Dijkstra's algorithm, and while
updating neighbor's costs the parent is updated with the direction the children
were at.

The reversed nodes are possible with a 1500 hardcoded cost.  1000 of the cost is
due to the distance to travel in order to reverse, and the other 500 is for the
time lost in waiting for the train to stop and accelerate.

Later when back tracing the parent list, from the direction recorded the
switches were switched to the correct orientation, ready for the train to run.

The implementation of a path is essentially a queue of nodes and direction
information.

The algorithm is carried out by a train planner task.  Each registered train
will own a planner, which will take trip planning requests and make call to the
Dijkstra's algorithm to resolve the request.

Once the planner have a resolved path it will read the path queue to fill out a
forward path until it finds a node that is the reverse of the previous node
examined.  This forward path is executed in the apparent method, by tracking the
train with each landmark update and stop the train at the correct spot.  Then
once the train stopped, if the path is not fully executed, then the train will
reverse and continue with the next forward path section of the full path.

The execution of a forward path, although said to be using the apparent method,
actually involved some subtleties in order to work around implementation
impedements.

The implementation of the execution actually slows down the train at most 4
times when the train is at 4 different distance ranges within its destination.
The main reason for this is because the tracking of the train in the execution
is linked to the tracking of the train in the tracking task, and the tracking
task contains possibility of missing edges.  Although the algorithm can handle
missed edge updates, if the last edge of the path is missed the algorithm will
not be able to stop the train.  Therefore the train has to be slow down so no
edge is missed.

A second benefit we gain from slowing down the train at different distance
towards the destination is if the path started to be short, then the train won't
accelerate to a high speed.


* Train Scheduling
------------------

The train scheduling component of the train application is a simple server that
take in schedules in forms of source and destination, and chooses a free train
to travel to the source and then to the destination.  It could be thought that
the train is going to the source to pick up an item and drop it down at
destination.

The schedules are kept in a queue to be scheduled in the sequence they came in.
The choic of train is totally based on which train is free and the first free
train will be chosen as the one that carry out the schedule.

The scheduler depends on the reservation system to ensure the trains does not
crash, and to reroute if a crash is avoided.

The original proposal included a better scheduler that schedules the path in
advance so that the trains will have very low possiblity of being saved by the
reservation system.  This proposal was not implemented because the tracking of
the train is not trustworthy enough to make schedules in advance to acceptable
precision.




* Console Commands
------------------

There are some new console commands are added to the system. The goal of these console command is to set some parameters of trains for each different ones. During the previous assignments, we find that some parameters are different for each trains, and they may even varies for the same train at different point of time. In this situation, giving these parameter by commands seem to be the best solution.

For example, one parameter that is unique to each train is the time for which the train needs to change the speed. For this parameter, we have a command to input different different time range for different trains. Thus we can get more accurate tracking on each train.

Besides commands for these essential attribution variables, there are also other commands. For instance, there is a command to tell system which way is the train's pickup at (Forward or Backward). This value is unknown to the system at the begining, and the system can do fairly good reservation when this value is not known. However, if we tell system the setup of pickups, the system can do more accurate reservation of a train. Especially which our new reservation system, input the pickup location can allow the trains to come as close as only 5cm away from each other.



Submitted files
===============








